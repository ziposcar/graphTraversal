#encoding:utf-8
from __future__ import division
import async_task
import cal_data_fit
import copy
import recordFun
import generate_data_ga  #数据生成器-----序列上的变量产生数据
import os
import sensitive_path_info
mm = sensitive_path_info.build_m()
# uncp = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
def table_handle(M):
    # 所有敏感路径入口点检测：pot = 1已完全覆盖所有的入口点；pot =0为未完全覆盖
    # 方法：查看table中是不是至少每一列都有一个在[0,1]之间的个体
    # 所有敏感路径完全覆盖检测：flag = 1为完全覆盖；flag=0为未完全覆盖。
    # 方法：查看二维表中的0是否已全覆盖上所有的敏感路径,每一列至少有一个0
    count = 0
    count1 = 0
    flag = 0
    pot = 0
    uncoverp = []
    potlist = []
    statistic = []
    print "M ==",len(M)
    for i in range(len(M)):
        # print len(M[i])
        print M[i]
    for k in range(len(M[0])):
        # print "第",k,"条路径"
        for j in range(len(M)):
            # print "第", j, "个测试用例的fit值",M[j][k]
            # print "table[j][k]", table[j][k]
            if M[j][k] == 0.0:  #table里面的fit值都是浮点数
                count = count + 1
            if M[j][k] >=0.0 and M[j][k] < 2:   # 这里实际上是<=2,cal_data_fit时，忘记归一化了，先这样
                count1 = count1 + 1  #解决老师关于统计有多少个个体能使path过了入口点但没有完全覆盖的问题
        if count == 0:
            uncoverp.append(k)
        if count1 != 0:
            potlist.append(k)
        statistic.append(count1)
        count = 0
        count1 = 0
    # print uncoverp
    if len(uncoverp) ==0:
        flag =1
    if len(potlist) == len(M[0]):
        pot = 1
    print " 统计有多少个个体能使各条path过了入口点但没有完全覆盖的statistic结果",statistic
    print flag,pot
    # recordFun.recordStatisticResult(statistic)
    return flag ,pot

def table_coverage(M):
    #统计路径覆盖率 = 已覆盖路径数/总的路径数
    count = 0
    uncoverp = 0
    Uncover_path_list = []
    for k in range(len(M[0])):
        for j in range(len(M)):
            if M[j][k] == 0.0:
                count = count + 1
        if count == 0:
            Uncover_path_list.append(k)
        count = 0
    print " 未覆盖的路径数uncoverp：", len(Uncover_path_list)
    print " len(M[0]）",len(M[0])
    coverage =((len(M[0]) - len(Uncover_path_list)) / len(M[0]))  # %
    print " 未覆盖的路径列表",Uncover_path_list
    print " 种群对所有路径的覆盖率",coverage
    return coverage,Uncover_path_list

def gdata(seq,SM):
    d = []
    M = []
    i = 1
    at = async_task.AsyncTask()
    os.system("mysql -uroot -pzip123 < D:\\WandS\\Graduation_Project\\graphTraversal-submit\\support\\SchoolMate.sql")
    for t_index, path in enumerate(seq):
        # print " 第",i," 个测试用例", path, len(path)
        # 对每一条path 求数据，运行，评估个体数据
        at.add(generate_data_ga.testProcee, copy.deepcopy(SM), path, t_index)
        cal_data_fit.deletefile(t_index)

    results = at.run()
    for data_result, test_fit, coverage in results:
        # data_result, test_fit, coverage = generate_data_ga.testProcee(SM, path, t_index)
        if len(test_fit) == 0:  #构造覆盖矩阵M
            M.append(mm)
        else:
            M.append(test_fit)
        # recordFun.recordTestCase(i,path,test_fit,coverage)
        d.append(data_result)
        i += 1
    return d, M

if __name__ == '__main__':
    Mv = [[0.0, 2, 0.0, 0.0, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 2, 2, 0.0, 2, 2, 0.0, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 0.0, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 1.00990099009901, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 0.0, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 1.0, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 1.00990099009901, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 0.0, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [0.0, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 0.0, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 0.0, 0.0, 2],
    [2, 2, 2, 2, 0.0, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2]]
    Mvv = [[2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 1.0, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 0.0, 0.0, 2],
         [0.0, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 1.00990099009901, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 1.00990099009901, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 0.0, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [0.0, 0.0, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 0.0],
         [2, 2, 2, 2, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 0.0, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [0.0, 0.0, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 0.0, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 0.0, 0.0, 2],
         [0.0, 2, 2, 2, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 0.0, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1.0, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2, 2, 0.0, 0.0, 2]]
    M = [[2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 1.0, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 0.0, 0.0, 2],
         [0.0, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 1.0, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 1.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 0.0, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [0.0, 0.0, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 0.0],
         [2, 2, 2, 2, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 0.0, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [0.0, 0.0, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 0.0, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 0.0, 0.0, 2],
         [0.0, 2, 2, 2, 2, 2, 0.0, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 0.0, 0.0, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 0.0, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2],
         [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0.0, 0.0, 2, 2, 0.0, 0.0, 2]]
    table_handle(M)
    table_coverage(M)
